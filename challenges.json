[
  {
    "date": "2026-02-19",
    "name": "Typed Middleware Pipeline with Retry & Cancellation",
    "difficulty": "Hard",
    "description": "You're building an internal HTTP gateway layer that processes outgoing requests through a chain of typed middleware (auth injection, logging, rate-limit headers). Each middleware can transform the request context, short-circuit with a typed error, and the pipeline runner supports per-request cancellation and automatic retry with exponential back-off.",
    "snippet": "\n// Key types at a glance\n\ntype Milliseconds = number & { readonly __brand: \"Milliseconds\" };\n\ninterface PipelineContext<TBody = unknown> {\n  readonly requestId: string;\n  url: string;\n  method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  headers: Record<string, string>;\n  body: TBody | undefined;\n  meta: Record<string, unknown>;\n}\n\ntype PipelineResult<TResponse, TError> =\n  | { readonly kind: \"success\"; readonly response: TResponse;\n      readonly durationMs: Milliseconds; readonly attempts: number }\n  | { readonly kind: \"failure\"; readonly error: TError;\n      readonly durationMs: Milliseconds; readonly attempts: number };\n\n// TODO (a) — fill in the body:\ntype Middleware<TBody, TResponse, TError> = never;\n\n// TODO (f) — implement this:\nasync function runPipeline<TBody, TResponse, TError>(\n  options: PipelineOptions<TBody, TResponse, TError>\n): Promise<PipelineResult<TResponse, TError>> { ... }\n",
    "goals": [
      "Define `Middleware`, `Executor`, `RetryPolicy`, and `PipelineOptions` as fully-typed generic aliases/interfaces with no `any` or `never` placeholders.",
      "Implement `runPipeline` with a recursive `dispatch` function that threads context through middlewares, supports short-circuiting, and retries failed attempts using the supplied `RetryPolicy` with exponential back-off.",
      "Implement the three middleware factories (`withBearerAuth`, `withRequestLogger`, `withRateLimitHeader`) and the `exponentialBackoff` helper so all five test cases pass.",
      "Implement `sleep` so it respects an optional `AbortSignal`, rejecting immediately with the signal's reason when already aborted or when aborted mid-sleep."
    ],
    "hints": [
      "For `Middleware<TBody, TResponse, TError>`, the `next` parameter's type is the same async function shape as the middleware itself minus the `next` arg — write it as an inline function type `(ctx: PipelineContext<TBody>) => Promise<PipelineResult<TResponse, TError>>`.",
      "In `runPipeline`, track `startTime = Date.now()` before the attempt loop and compute `durationMs` only once when you're ready to return — the `durationMs` fields from the executor are intentionally ignored at the pipeline level.",
      "For `sleep` + `AbortSignal`, register a one-shot `'abort'` event listener and also check `signal.aborted` synchronously at the top of the function before creating the timeout."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Handbook — Conditional Types & infer",
        "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html"
      },
      {
        "title": "MDN — AbortSignal & AbortController",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
      },
      {
        "title": "TypeScript Handbook — Utility Types (Extract, Record, Pick…)",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      }
    ]
  },
  {
    "date": "2026-02-20",
    "name": "Typed Inventory Aggregator",
    "difficulty": "Easy",
    "description": "You're building a dashboard for a small e-commerce warehouse. Given a flat list of product entries (each with a category, SKU, price, and stock count), aggregate them into a per-category summary — the hardest part is getting the TypeScript types exactly right.",
    "snippet": "// Key types & main function signature\n\ntype Sku = string & { readonly _brand: \"Sku\" };\n\ninterface InventoryItem {\n  sku:          Sku;\n  name:         string;\n  category:     string;\n  priceUsd:     number;\n  stock:        number;\n}\n\ninterface CategorySummary {\n  totalItems:     number;\n  totalStock:     number;\n  totalValueUsd:  number;\n  cheapestSku:    Sku;\n  mostStockedSku: Sku;\n}\n\ntype InventorySummary = Record<string, CategorySummary>;\n\nfunction aggregateInventory(items: InventoryItem[]): InventorySummary { ... }\nfunction topCategories(summary: InventorySummary, n: number): string[] { ... }",
    "goals": [
      "Define a branded `Sku` type and implement `toSku` without using `any` or a type assertion.",
      "Build the `InventoryItem` and `CategorySummary` interfaces with all required fields typed correctly.",
      "Implement `aggregateInventory` to produce a correct per-category summary in a single pass over the items array.",
      "Implement `topCategories` returning category names sorted by total inventory value descending, capped at n results."
    ],
    "hints": [
      "For `toSku`, look at how TypeScript's `satisfies` operator or a simple return-type annotation can coerce a `string` to a branded type without writing `as Sku`.",
      "Use a `for...of` loop or `Array.reduce` over the items and build up the `InventorySummary` object incrementally — initialise each category bucket on first encounter.",
      "For `topCategories`, `Object.entries` gives you `[category, summary]` pairs you can sort by `totalValueUsd` before slicing to `n`."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Utility Types (Record)",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type"
      },
      {
        "title": "TypeScript Handbook — Interfaces",
        "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
      },
      {
        "title": "TypeScript 5.0 — satisfies operator",
        "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator"
      },
      {
        "title": "MDN — Array.prototype.reduce",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
      }
    ]
  },
  {
    "date": "2026-02-21",
    "name": "Paginated API Client with Typed Result Accumulation",
    "difficulty": "Hard",
    "description": "You're building a typed API client for an analytics platform that exposes cursor-based paginated endpoints. The client must traverse all pages concurrently (up to a configurable limit), accumulate results into a strongly-typed aggregate, and surface per-page errors without aborting the entire fetch — all without a single `any` or type assertion.",
    "snippet": "// Key types and main function signature\n\ndeclare const __brand: unique symbol;\ntype Brand<B> = { readonly [__brand]: B };\n\ntype Cursor      = string & Brand<\"Cursor\">;\ntype EndpointPath = string & Brand<\"EndpointPath\">;\n\ntype PageResponse<T> = {\n  items:      T[];\n  nextCursor: Cursor | undefined;\n  pageIndex:  number;\n};\n\ntype FetchResult<T> =\n  | { ok: true;  data: T }\n  | { ok: false; error: PageError };\n\ntype AccumulatedResult<T> = /* discriminated by `ok` — you define it */;\n\ntype PageFetcher<T> =\n  (req: PageRequest) => Promise<FetchResult<PageResponse<T>>>;\n\n// ── Core entry point ──────────────────────────────────────────\nasync function fetchAllPages<T>(\n  endpoint: EndpointPath,\n  fetcher:  PageFetcher<T>,\n  options?: FetchAllOptions\n): Promise<AccumulatedResult<T>>\n",
    "goals": [
      "Define branded string types `Cursor` and `EndpointPath` using a `unique symbol` brand and a single generic branding helper — no `as` outside that helper.",
      "Model `FetchResult<T>` and `AccumulatedResult<T>` as discriminated unions so TypeScript can narrow them without type assertions.",
      "Implement `withConcurrencyLimit<R>` that runs async task factories with a configurable concurrency cap and returns results in original order.",
      "Implement `fetchAllPages<T>` that traverses cursor-based pages using `withConcurrencyLimit`, collects items in page order, and accumulates per-page errors without aborting the traversal."
    ],
    "hints": [
      "For `withConcurrencyLimit`, track results by index in a pre-allocated array and maintain a pointer to the next task to start — avoid `Promise.all` on the full set.",
      "The `AccumulatedResult<T>` discriminated union should mirror `FetchResult` — an `ok: true` branch with no `errors` field forces callers through `handleAccumulatedResult` to access errors safely.",
      "When traversing pages, only enqueue the next cursor if the current page succeeded — failed pages cannot yield a `nextCursor`, so that branch of the graph is naturally pruned."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Branded / Nominal Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html"
      },
      {
        "title": "TypeScript Handbook — Narrowing & Discriminated Unions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "MDN — Promise.allSettled",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "title": "TypeScript Handbook — Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      }
    ]
  }
]
