[
  {
    "date": "2026-02-19",
    "name": "Typed Middleware Pipeline with Retry & Cancellation",
    "difficulty": "Hard",
    "description": "You're building an internal HTTP gateway layer that processes outgoing requests through a chain of typed middleware (auth injection, logging, rate-limit headers). Each middleware can transform the request context, short-circuit with a typed error, and the pipeline runner supports per-request cancellation and automatic retry with exponential back-off.",
    "snippet": "\n// Key types at a glance\n\ntype Milliseconds = number & { readonly __brand: \"Milliseconds\" };\n\ninterface PipelineContext<TBody = unknown> {\n  readonly requestId: string;\n  url: string;\n  method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  headers: Record<string, string>;\n  body: TBody | undefined;\n  meta: Record<string, unknown>;\n}\n\ntype PipelineResult<TResponse, TError> =\n  | { readonly kind: \"success\"; readonly response: TResponse;\n      readonly durationMs: Milliseconds; readonly attempts: number }\n  | { readonly kind: \"failure\"; readonly error: TError;\n      readonly durationMs: Milliseconds; readonly attempts: number };\n\n// TODO (a) — fill in the body:\ntype Middleware<TBody, TResponse, TError> = never;\n\n// TODO (f) — implement this:\nasync function runPipeline<TBody, TResponse, TError>(\n  options: PipelineOptions<TBody, TResponse, TError>\n): Promise<PipelineResult<TResponse, TError>> { ... }\n",
    "goals": [
      "Define `Middleware`, `Executor`, `RetryPolicy`, and `PipelineOptions` as fully-typed generic aliases/interfaces with no `any` or `never` placeholders.",
      "Implement `runPipeline` with a recursive `dispatch` function that threads context through middlewares, supports short-circuiting, and retries failed attempts using the supplied `RetryPolicy` with exponential back-off.",
      "Implement the three middleware factories (`withBearerAuth`, `withRequestLogger`, `withRateLimitHeader`) and the `exponentialBackoff` helper so all five test cases pass.",
      "Implement `sleep` so it respects an optional `AbortSignal`, rejecting immediately with the signal's reason when already aborted or when aborted mid-sleep."
    ],
    "hints": [
      "For `Middleware<TBody, TResponse, TError>`, the `next` parameter's type is the same async function shape as the middleware itself minus the `next` arg — write it as an inline function type `(ctx: PipelineContext<TBody>) => Promise<PipelineResult<TResponse, TError>>`.",
      "In `runPipeline`, track `startTime = Date.now()` before the attempt loop and compute `durationMs` only once when you're ready to return — the `durationMs` fields from the executor are intentionally ignored at the pipeline level.",
      "For `sleep` + `AbortSignal`, register a one-shot `'abort'` event listener and also check `signal.aborted` synchronously at the top of the function before creating the timeout."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Handbook — Conditional Types & infer",
        "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html"
      },
      {
        "title": "MDN — AbortSignal & AbortController",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
      },
      {
        "title": "TypeScript Handbook — Utility Types (Extract, Record, Pick…)",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      }
    ]
  },
  {
    "date": "2026-02-20",
    "name": "Typed Inventory Aggregator",
    "difficulty": "Easy",
    "description": "You're building a dashboard for a small e-commerce warehouse. Given a flat list of product entries (each with a category, SKU, price, and stock count), aggregate them into a per-category summary — the hardest part is getting the TypeScript types exactly right.",
    "snippet": "// Key types & main function signature\n\ntype Sku = string & { readonly _brand: \"Sku\" };\n\ninterface InventoryItem {\n  sku:          Sku;\n  name:         string;\n  category:     string;\n  priceUsd:     number;\n  stock:        number;\n}\n\ninterface CategorySummary {\n  totalItems:     number;\n  totalStock:     number;\n  totalValueUsd:  number;\n  cheapestSku:    Sku;\n  mostStockedSku: Sku;\n}\n\ntype InventorySummary = Record<string, CategorySummary>;\n\nfunction aggregateInventory(items: InventoryItem[]): InventorySummary { ... }\nfunction topCategories(summary: InventorySummary, n: number): string[] { ... }",
    "goals": [
      "Define a branded `Sku` type and implement `toSku` without using `any` or a type assertion.",
      "Build the `InventoryItem` and `CategorySummary` interfaces with all required fields typed correctly.",
      "Implement `aggregateInventory` to produce a correct per-category summary in a single pass over the items array.",
      "Implement `topCategories` returning category names sorted by total inventory value descending, capped at n results."
    ],
    "hints": [
      "For `toSku`, look at how TypeScript's `satisfies` operator or a simple return-type annotation can coerce a `string` to a branded type without writing `as Sku`.",
      "Use a `for...of` loop or `Array.reduce` over the items and build up the `InventorySummary` object incrementally — initialise each category bucket on first encounter.",
      "For `topCategories`, `Object.entries` gives you `[category, summary]` pairs you can sort by `totalValueUsd` before slicing to `n`."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Utility Types (Record)",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type"
      },
      {
        "title": "TypeScript Handbook — Interfaces",
        "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
      },
      {
        "title": "TypeScript 5.0 — satisfies operator",
        "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator"
      },
      {
        "title": "MDN — Array.prototype.reduce",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
      }
    ]
  },
  {
    "date": "2026-02-21",
    "name": "Paginated API Client with Typed Result Accumulation",
    "difficulty": "Hard",
    "description": "You're building a typed API client for an analytics platform that exposes cursor-based paginated endpoints. The client must traverse all pages concurrently (up to a configurable limit), accumulate results into a strongly-typed aggregate, and surface per-page errors without aborting the entire fetch — all without a single `any` or type assertion.",
    "snippet": "// Key types and main function signature\n\ndeclare const __brand: unique symbol;\ntype Brand<B> = { readonly [__brand]: B };\n\ntype Cursor      = string & Brand<\"Cursor\">;\ntype EndpointPath = string & Brand<\"EndpointPath\">;\n\ntype PageResponse<T> = {\n  items:      T[];\n  nextCursor: Cursor | undefined;\n  pageIndex:  number;\n};\n\ntype FetchResult<T> =\n  | { ok: true;  data: T }\n  | { ok: false; error: PageError };\n\ntype AccumulatedResult<T> = /* discriminated by `ok` — you define it */;\n\ntype PageFetcher<T> =\n  (req: PageRequest) => Promise<FetchResult<PageResponse<T>>>;\n\n// ── Core entry point ──────────────────────────────────────────\nasync function fetchAllPages<T>(\n  endpoint: EndpointPath,\n  fetcher:  PageFetcher<T>,\n  options?: FetchAllOptions\n): Promise<AccumulatedResult<T>>\n",
    "goals": [
      "Define branded string types `Cursor` and `EndpointPath` using a `unique symbol` brand and a single generic branding helper — no `as` outside that helper.",
      "Model `FetchResult<T>` and `AccumulatedResult<T>` as discriminated unions so TypeScript can narrow them without type assertions.",
      "Implement `withConcurrencyLimit<R>` that runs async task factories with a configurable concurrency cap and returns results in original order.",
      "Implement `fetchAllPages<T>` that traverses cursor-based pages using `withConcurrencyLimit`, collects items in page order, and accumulates per-page errors without aborting the traversal."
    ],
    "hints": [
      "For `withConcurrencyLimit`, track results by index in a pre-allocated array and maintain a pointer to the next task to start — avoid `Promise.all` on the full set.",
      "The `AccumulatedResult<T>` discriminated union should mirror `FetchResult` — an `ok: true` branch with no `errors` field forces callers through `handleAccumulatedResult` to access errors safely.",
      "When traversing pages, only enqueue the next cursor if the current page succeeded — failed pages cannot yield a `nextCursor`, so that branch of the graph is naturally pruned."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Branded / Nominal Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html"
      },
      {
        "title": "TypeScript Handbook — Narrowing & Discriminated Unions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "MDN — Promise.allSettled",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "title": "TypeScript Handbook — Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      }
    ]
  },
  {
    "date": "2026-02-22",
    "name": "Typed Event Log Parser",
    "difficulty": "Easy",
    "description": "You're building a monitoring dashboard for a cloud platform. Raw event logs arrive as untyped JSON blobs — your job is to safely parse them into a discriminated union of strongly-typed events, then aggregate counts and extract the latest timestamp per event kind.",
    "snippet": "/** All supported event kinds */\ntype EventKind = \"deploy\" | \"error\" | \"scale\" | \"alert\";\n\ninterface AlertEvent {\n  kind: \"alert\";\n  timestamp: number;\n  alertName: string;\n  severity: \"low\" | \"medium\" | \"high\" | \"critical\";\n}\n\ntype AppEvent = DeployEvent | ErrorEvent | ScaleEvent | AlertEvent;\n\n/** Mapped over EventKind — adding a new kind extends this automatically */\ntype EventSummary = {\n  [K in EventKind]: {\n    count: number;\n    latestTimestamp: number | null;\n  };\n};\n\n/** Parse one unknown blob → typed AppEvent or null if invalid */\nfunction parseEvent(raw: unknown): AppEvent | null { ... }\n\n/** Parse an array of unknown blobs, silently dropping invalid entries */\nfunction parseEventLog(raw: unknown): AppEvent[] { ... }\n\n/** Aggregate parsed events into per-kind counts + latest timestamps */\nfunction summariseEvents(events: AppEvent[]): EventSummary { ... }\n",
    "goals": [
      "Implement `parseEvent` to safely narrow `unknown` input into a typed `AppEvent` discriminated union — no `any`, no type assertions.",
      "Implement `parseEventLog` to filter an unknown array, silently dropping entries that fail validation.",
      "Define `EventSummary` as a mapped type over `EventKind` so the shape automatically extends when a new kind is added.",
      "Implement `summariseEvents` to aggregate event counts and track the latest timestamp per kind, seeding all keys up front for compile-time exhaustiveness."
    ],
    "hints": [
      "Use `typeof raw === 'object' && raw !== null && 'kind' in raw` to safely access fields on an `unknown` value — no casting needed.",
      "A `switch` on `event.kind` after you've confirmed it's a valid `EventKind` lets TypeScript narrow each branch to the correct interface.",
      "Initialise the `EventSummary` accumulator by listing every `EventKind` literal explicitly — TypeScript will flag a missing key as a compile error."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Narrowing",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html"
      },
      {
        "title": "TypeScript Handbook — Discriminated Unions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "TypeScript Handbook — Mapped Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html"
      },
      {
        "title": "MDN — Array.isArray",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
      }
    ]
  },
  {
    "date": "2026-02-23",
    "name": "Typed Reactive State Machine",
    "difficulty": "Hard",
    "description": "You're building the core of a checkout flow for an e-commerce platform. The checkout process moves through well-defined states (idle → validating → payment → confirmed / failed), and every transition must be explicitly allowed, carry typed payloads, and notify strongly-typed subscribers — all enforced at compile time.",
    "snippet": "export type CheckoutState =\n  | IdleState\n  | ValidatingState\n  | PaymentState\n  | ConfirmedState\n  | FailedState;\n\n// Each event variant carries only the payload its transition needs:\nexport type CheckoutEvent = never; // TODO: your discriminated union here\n\n// TransitionMap maps every event `type` to its allowed source states\n// and a pure reduce function — narrowed at the type level:\nexport type TransitionMap = {\n  [E in CheckoutEvent as E[\"type\"]]: {\n    from: ReadonlyArray<CheckoutState[\"kind\"]>;\n    reduce: (state: /* narrowed */ CheckoutState, event: E) => CheckoutState;\n  };\n};\n\nexport class CheckoutMachine {\n  constructor(initialCart: CartItem[]);\n  getState(): CheckoutState;\n  send(event: CheckoutEvent): CheckoutState;\n  subscribe(fn: Subscriber): () => void;\n  reset(newCart?: CartItem[]): CheckoutState;\n}\n",
    "goals": [
      "Define a discriminated `CheckoutEvent` union whose variants carry only the payload each transition needs, and a `TransitionMap` mapped type where `reduce` receives narrowed state and event types — not the full unions.",
      "Implement `CheckoutMachine` so that `send()` enforces allowed transitions at runtime, throws a `TypeError` on illegal ones, and notifies subscribers with `(nextState, prevState)`.",
      "Implement `subscribe()` returning a working unsubscribe function, and `reset()` as a convenience wrapper that guards against calls from non-terminal states.",
      "Implement `cartTotal` using a single `reduce` call and `assertNeverState` as an exhaustive compile-time + runtime safety net."
    ],
    "hints": [
      "To get narrowed types in `TransitionMap`, try a helper type like `type EventByType<T extends CheckoutEvent[\"type\"]> = Extract<CheckoutEvent, { type: T }>` and use it in the mapped type's `reduce` signature.",
      "Use `Extract<CheckoutState, { kind: K }>` to narrow the `state` parameter in each `reduce` function — this keeps the transition table fully type-safe without any casts.",
      "Store subscribers in a `Set<Subscriber>` so that returning `() => set.delete(fn)` from `subscribe()` gives you a clean, allocation-light unsubscribe pattern."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Discriminated Unions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "TypeScript Handbook — Mapped Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html"
      },
      {
        "title": "TypeScript Handbook — Conditional Types & infer",
        "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html"
      },
      {
        "title": "TypeScript Handbook — Extract Utility Type",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union"
      }
    ]
  },
  {
    "date": "2026-02-24",
    "name": "Typed Contact Book Lookup",
    "difficulty": "Easy",
    "description": "You're building a small contact book utility for an internal HR tool. Given a list of contacts with varying optional fields, you must build a strongly-typed lookup index and implement search/filter helpers — the challenge is in the types, not the logic.",
    "snippet": "/** The department a contact belongs to. */\ntype Department = \"engineering\" | \"design\" | \"marketing\" | \"hr\" | \"finance\";\n\n/** A contact's role seniority. */\ntype Seniority = \"junior\" | \"mid\" | \"senior\" | \"lead\" | \"manager\";\n\ninterface Contact {\n  id: string;\n  name: string;\n  email: string;\n  department: Department;\n  seniority: Seniority;\n  phone?: string;\n  tags?: string[];\n}\n\n// Your job: define these three types using built-in utility types...\ntype ContactIndex  = Record<string, Contact>;       // TODO: use Record<>\ntype ContactSummary = Pick<Contact, \"id\" | ...>;    // TODO: use Pick<>\ntype SearchFilters  = Partial<Contact>;             // TODO: use Partial<>\n\n// ...then implement these three functions:\nfunction buildIndex(contacts: Contact[]): ContactIndex { ... }\nfunction summarise(index: ContactIndex): ContactSummary[] { ... }\nfunction filterContacts(contacts: Contact[], filters: SearchFilters): Contact[] { ... }",
    "goals": [
      "Define `ContactIndex`, `ContactSummary`, and `SearchFilters` using the `Record`, `Pick`, and `Partial` built-in utility types respectively.",
      "Implement `buildIndex` to convert a `Contact[]` into a `ContactIndex` keyed by each contact's `id`.",
      "Implement `summarise` to extract only the `id`, `name`, `email`, and `department` fields from every contact in a `ContactIndex`.",
      "Implement `filterContacts` to return contacts matching ALL provided filter fields, with special subset-matching logic for the optional `tags` array."
    ],
    "hints": [
      "For `filterContacts`, iterate over the keys of the `filters` object with `Object.keys` — but remember each value may be `undefined` (Partial!), so skip those keys entirely.",
      "When checking `tags`, `Array.prototype.every` paired with `Array.prototype.includes` is your friend for verifying that all filter tags exist on the contact.",
      "The `Pick` utility type takes a type and a union of string literal keys: `Pick<Contact, 'id' | 'name'>` — make sure you only name the four required fields for `ContactSummary`."
    ],
    "docs": [
      {
        "title": "TypeScript Utility Types (Pick, Partial, Record)",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      },
      {
        "title": "TypeScript Handbook — Object Types & Optional Properties",
        "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
      },
      {
        "title": "MDN — Array.prototype.every()",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every"
      },
      {
        "title": "MDN — Object.keys() / Object.values()",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
      }
    ]
  },
  {
    "date": "2026-02-25",
    "name": "Typed Middleware Pipeline Builder",
    "difficulty": "Medium",
    "description": "You're building the request-handling core of an internal HTTP gateway. Middleware functions transform a typed context object one step at a time — the challenge is composing them into a pipeline where each middleware's output type flows into the next middleware's input type, all enforced at compile time.",
    "snippet": "/** A single middleware: receives a context of type In, returns Out. */\ntype Middleware<In, Out> = (ctx: In) => Out;\n\n/** Unwrap a Promise<T> → T; leave non-promise types unchanged. */\ntype Awaited_<T> = /* TODO: conditional type using infer */;\n\n/** Infer the output type of the last middleware in a tuple. */\ntype PipelineOutput<\n  Middlewares extends readonly Middleware<unknown, unknown>[]\n> = /* TODO: recursive conditional type */;\n\n/** Discriminated union returned by runPipeline. */\ntype PipelineResult<T> =\n  | { ok: true; value: T }\n  | { ok: false; error: string; step: number };\n\n/** Chain two middlewares — intermediate type is fully inferred. */\ndeclare function compose<A, B, C>(\n  f: Middleware<A, B>,\n  g: Middleware<B, C>\n): Middleware<A, C>;\n\n/** Run an ordered array of middlewares, catching per-step errors. */\ndeclare function runPipeline(\n  initial: unknown,\n  middlewares: Array<Middleware<unknown, unknown>>\n): PipelineResult<unknown>;\n",
    "goals": [
      "Implement `Awaited_<T>` and `PipelineOutput<Middlewares>` as conditional types that use `infer` to extract inner and last-middleware output types.",
      "Implement `compose` and `composeAsync` as fully generic functions that chain two middlewares with no manual type annotations at call sites.",
      "Implement `runPipeline` to execute middlewares sequentially, returning a typed `PipelineResult` discriminated union that captures both success and per-step failure.",
      "Define the `Brand` helper and `AuthedContext` branded type, then implement `withAuth` as a middleware that narrows a plain `RequestContext` into an `AuthedContext` or throws."
    ],
    "hints": [
      "For `PipelineOutput`, use a variadic tuple pattern: `Middlewares extends [...infer _Init, infer Last]` to grab only the final element, then extract its output with a second `infer`.",
      "A branded type is just an intersection with a phantom property: `T & { readonly __brand: B }` — this makes two structurally identical types nominally distinct.",
      "In `runPipeline`, keep a `current: unknown` variable and iterate with a `for` loop so you can track the step index when catching errors."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook: Conditional Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html"
      },
      {
        "title": "TypeScript Handbook: Inferring Within Conditional Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types"
      },
      {
        "title": "TypeScript Handbook: Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Deep Dive: Branded Types",
        "url": "https://basarat.gitbook.io/typescript/main-1/nominaltyping"
      }
    ]
  },
  {
    "date": "2026-02-26",
    "name": "Typed Product Inventory Aggregator",
    "difficulty": "Easy",
    "description": "You're building a back-office tool for an e-commerce warehouse. Raw inventory records arrive as unknown JSON, and you must safely validate them, group them by category, and compute per-category summaries — the challenge is keeping every step fully typed without reaching for `any`.",
    "snippet": "\n// Key types\nexport type Category = \"electronics\" | \"clothing\" | \"food\" | \"furniture\";\n\nexport interface Product {\n  id: string;\n  name: string;\n  category: Category;\n  priceUsd: number;   // > 0\n  stock: number;      // non-negative integer\n}\n\nexport type Result<T, E> =\n  | { ok: true;  value: T }\n  | { ok: false; error: E };\n\nexport interface CategorySummary {\n  category: Category;\n  productCount: number;\n  totalStock: number;\n  averagePriceUsd: number;\n  cheapestProduct: Pick<Product, \"id\" | \"name\" | \"priceUsd\">;\n}\n\n// Functions to implement\nexport function parseProduct(raw: unknown): Result<Product, string> { ... }\nexport function groupByCategory(products: Product[]): Map<Category, Product[]> { ... }\nexport function summariseCategory(category: Category, products: Product[]): CategorySummary { ... }\nexport function buildInventoryReport(rawRecords: unknown[]): InventoryReport { ... }\n",
    "goals": [
      "Implement `parseProduct` to safely narrow `unknown` → `Product` using a `Result` discriminated union — no `any` or `as` allowed.",
      "Implement `groupByCategory` to bucket valid products into a `Map<Category, Product[]>`.",
      "Implement `summariseCategory` to compute per-category totals, averages (2 d.p.), and the cheapest product using `Pick<Product, ...>`.",
      "Implement `buildInventoryReport` to orchestrate the full pipeline: parse all raw records, collect indexed `ParseError`s, aggregate summaries, and return a sorted `InventoryReport`."
    ],
    "hints": [
      "Narrow `unknown` incrementally: first check `typeof raw === 'object' && raw !== null`, then use the `in` operator to confirm each field exists before checking its type or value.",
      "The `Result<T, E>` union is discriminated on the `ok` boolean — TypeScript will narrow `value` vs `error` automatically inside an `if (result.ok)` block.",
      "For `Pick<Product, 'id' | 'name' | 'priceUsd'>`, you don't need to construct a new type — just return an object literal with exactly those three keys and TypeScript will enforce the shape."
    ],
    "docs": [
      {
        "title": "TypeScript – Narrowing",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html"
      },
      {
        "title": "TypeScript – Utility Types (Pick, Record, …)",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      },
      {
        "title": "TypeScript – Discriminated Unions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "MDN – Map",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
      }
    ]
  }
]
