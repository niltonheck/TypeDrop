[
  {
    "date": "2026-02-17",
    "name": "Strict Omit",
    "difficulty": "Medium",
    "description": "Implement a StrictOmit type that works like Omit, but raises a compile error if you try to omit keys that don't exist on the original type.",
    "snippet": "type StrictOmit<T, K extends keyof T> = /* your implementation */"
  },
  {
    "date": "2026-02-18",
    "name": "Paginated API Client with Typed Cursors",
    "difficulty": "Medium",
    "description": "You're building a typed API client for a product catalog service. The API uses cursor-based pagination where each resource type has its own cursor shape — you must model this with generics and discriminated unions so callers never mix up cursors across endpoints.",
    "snippet": "declare const __brand: unique symbol;\ntype Cursor<TResource extends string> = string & { readonly [__brand]: TResource };\n\ninterface RawPage {\n  items: unknown[];\n  total: number;\n  nextCursor: string | null;\n}\n\n// You define these:\ntype Page<TItem, TResource extends string> = never;     // TODO\ntype Endpoint<TItem, TResource extends string> = never; // TODO\n\n// Then implement:\ndeclare function fetchPage<TItem, TResource extends string>(\n  endpoint: Endpoint<TItem, TResource>,\n  cursor?: Cursor<TResource>         // branded — can't mix product/order cursors!\n): Promise<Page<TItem, TResource>>;\n\ndeclare function collectAllPages<TItem, TResource extends string>(\n  endpoint: Endpoint<TItem, TResource>\n): Promise<TItem[]>;",
    "goals": [
      "Define a branded `Cursor<TResource>` type that prevents passing an order cursor to a product endpoint at compile time",
      "Model `Page<TItem, TResource>` and `Endpoint<TItem, TResource>` as generic types that thread the same `TResource` literal through cursor branding",
      "Implement `fetchPage` to call the endpoint's fetcher, validate each item, and return a properly typed `Page`",
      "Implement `collectAllPages` to follow `nextCursor` links sequentially until exhausted, returning a flat `TItem[]`"
    ],
    "hints": [
      "A branded type is just an intersection with a unique phantom property — `type Cursor<R extends string> = string & { readonly [__brand]: R }`",
      "To create a branded cursor from a raw API string without spreading `as` everywhere, use the pre-written `brandCursor` helper inside your `fetchPage` implementation",
      "For `collectAllPages`, a `while (cursor !== null)` loop that reassigns `cursor = page.nextCursor` after each `await fetchPage(...)` is the cleanest pattern"
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Handbook — Utility Types",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      },
      {
        "title": "TypeScript Handbook — Narrowing",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html"
      },
      {
        "title": "TypeScript Deep Dive — Branded Types",
        "url": "https://basarat.gitbook.io/typescript/main-1/nominaltyping"
      }
    ]
  },
  {
    "date": "2026-02-18",
    "name": "Typed Retry Pipeline with Result<T, E>",
    "difficulty": "Medium",
    "description": "You're building a resilient data-ingestion service that fetches records from unreliable third-party APIs. Each fetch operation can fail with distinct, typed errors — and callers need to configure per-operation retry budgets while getting back a strongly-typed Result instead of raw thrown exceptions.",
    "snippet": "// Core types and main function signature\n\nexport type Ok<T>  = { readonly _tag: \"ok\";  readonly value: T };\nexport type Err<E> = { readonly _tag: \"err\"; readonly error: E };\nexport type Result<T, E> = Ok<T> | Err<E>;\n\nexport type FetchError =\n  | { kind: \"network\"; message: string; statusCode: number }\n  | { kind: \"parse\";   message: string; raw: string }\n  | { kind: \"timeout\"; message: string; afterMs: number };\n\nexport interface RetryOptions {\n  maxAttempts: number; // total attempts (>= 1)\n  baseDelayMs: number; // delay = baseDelayMs * 2^attemptIndex\n}\n\nexport async function withRetry<T, E>(\n  operation: () => Promise<Result<T, E>>,\n  options: RetryOptions\n): Promise<Result<T, E>> { /* TODO */ throw new Error(\"not implemented\"); }",
    "goals": [
      "Define the Ok<T>/Err<E> discriminated union and the FetchError typed error hierarchy, then implement the ok() and err() constructor helpers.",
      "Implement the isOk and isErr type-guard functions so callers can narrow a Result<T,E> to its concrete variant without casting.",
      "Implement mapResult and matchResult to transform and consume Result values in a fully type-safe, exception-free style.",
      "Implement withRetry so it re-invokes a fallible async operation up to maxAttempts times with exponential back-off, returning the first Ok or the final Err."
    ],
    "hints": [
      "For Ok<T> and Err<E>, use a readonly literal discriminant field (e.g. `_tag: 'ok'`) — TypeScript will use it to narrow the union in isOk/isErr without any casting.",
      "In withRetry, track the 0-based attempt index in a loop; the delay before attempt i+1 is `baseDelayMs * Math.pow(2, i)` — await a small Promise timeout helper between retries.",
      "matchResult can be implemented in two lines using isOk/isErr — let the type guards do the narrowing so you never need `as` or `any`."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook – Discriminated Unions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "TypeScript Handbook – Generic Functions",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Handbook – Narrowing (type predicates)",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates"
      },
      {
        "title": "MDN – Promise & async/await",
        "url": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS/Promises"
      }
    ]
  },
  {
    "date": "2026-02-18",
    "name": "Typed Event Emitter with Middleware Chain",
    "difficulty": "Medium",
    "description": "You're building a plugin-friendly analytics SDK where every tracked event flows through a configurable middleware chain before being dispatched. Each middleware can transform the event payload, short-circuit the chain, or pass control to the next handler — all with full type safety across a heterogeneous event map.",
    "snippet": "// Core types and main class signature at a glance\n\nexport type EventMap = Record<string, object>;\n\nexport type Middleware<TPayload extends object> = (\n  payload: TPayload,\n  next: (payload: TPayload) => void\n) => void;\n\nexport function composeMiddleware<TPayload extends object>(\n  middlewares: ReadonlyArray<Middleware<TPayload>>\n): Middleware<TPayload> { /* ... */ }\n\n// Usage example:\ninterface AppEvents extends EventMap {\n  pageView: { path: string; userId: string };\n  purchase: { itemId: string; price: number; currency: string };\n}\n\nexport class TypedEmitter<TMap extends EventMap> {\n  use<K extends keyof TMap>(event: K, mw: Middleware<TMap[K]>): this { /* ... */ }\n  on<K extends keyof TMap>(event: K, handler: (payload: TMap[K]) => void): this { /* ... */ }\n  emit<K extends keyof TMap>(event: K, payload: TMap[K]): void { /* ... */ }\n}\n",
    "goals": [
      "Define the `Middleware<TPayload>` type and implement `composeMiddleware` so middleware run left-to-right, threading the payload and supporting short-circuiting.",
      "Implement `TypedEmitter<TMap>` with per-event middleware and handler registries, keyed by `keyof TMap`.",
      "Ensure `use`, `on`, and `emit` are fully type-safe: the payload type for each event is inferred from `TMap` without any `any` or casts.",
      "Handle edge cases: no registered middleware/handlers (no-op), short-circuiting, and multiple terminal handlers all receiving the final mutated payload."
    ],
    "hints": [
      "For `composeMiddleware`, think recursively or with `reduceRight` — each middleware wraps the remainder of the chain as its own `next`.",
      "Inside `TypedEmitter`, you can't use `TMap[K]` as a storage key type directly. Consider using `Map<keyof TMap, ...>` with a helper type or storing handlers as `Array<(p: object) => void>` keyed by event name — the public API still enforces the correct types.",
      "Returning `this` from `use` and `on` enables fluent chaining; TypeScript will infer the concrete subclass type if you ever extend `TypedEmitter`."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook – Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Handbook – keyof & Indexed Access Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html"
      },
      {
        "title": "TypeScript Handbook – Mapped Types",
        "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html"
      },
      {
        "title": "MDN – Array.prototype.reduceRight",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight"
      }
    ]
  },
  {
    "date": "2026-02-18",
    "name": "Typed In-Memory LRU Cache with TTL",
    "difficulty": "Medium",
    "description": "You're building a client-side data layer for a dashboard that fetches expensive aggregations from a REST API. To avoid redundant network calls, you need a generic, strongly-typed LRU (Least Recently Used) cache that also supports per-entry TTL (time-to-live) expiration — with a branded key type so callers can't accidentally mix cache namespaces.",
    "snippet": "// Key types needed to understand the main factory:\n\ntype CacheKey<NS extends string> = string & { readonly __ns: NS };\n\ntype CacheEntry<T> = {\n  value: T;\n  insertedAt: number; // Date.now() ms\n  ttl: number;        // 0 = no expiry\n};\n\ntype CacheOptions = {\n  maxSize: number;\n  defaultTtl: number;\n};\n\ninterface LRUCache<NS extends string, T> {\n  set(key: CacheKey<NS>, value: T, ttl?: number): void;\n  get(key: CacheKey<NS>): T | undefined;\n  delete(key: CacheKey<NS>): boolean;\n  clear(): void;\n  size(): number;\n  keys(): ReadonlyArray<CacheKey<NS>>;\n}\n\n// Main factory — you implement this:\nfunction createLRUCache<NS extends string, T>(\n  ns: NS,\n  options: CacheOptions\n): LRUCache<NS, T> { /* ... */ }\n",
    "goals": [
      "Define a branded `CacheKey<NS>` type so that keys from different namespaces are incompatible at compile time.",
      "Implement `createLRUCache` returning an object that fully satisfies the `LRUCache<NS, T>` interface.",
      "Correctly handle LRU eviction using insertion-order tracking so the least-recently-used entry is dropped when `maxSize` is exceeded.",
      "Support per-entry TTL expiration: expired entries must be treated as absent on `get`, `size`, and `keys`."
    ],
    "hints": [
      "A JavaScript `Map` preserves insertion order — you can simulate LRU by deleting a key and re-inserting it on every `set` or cache hit, so the Map's natural order always reflects LRU → MRU.",
      "To create a branded type without `as`, define the brand as a `readonly` property in an intersection: `type CacheKey<NS extends string> = string & { readonly __ns: NS }` — then use a single, carefully scoped assertion only inside `makeCacheKey`.",
      "For `size()` and `keys()`, iterate the internal Map and filter out expired entries lazily (check `Date.now() - entry.insertedAt > entry.ttl`) rather than running a background sweep."
    ],
    "docs": [
      {
        "title": "TypeScript Handbook — Generics",
        "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html"
      },
      {
        "title": "TypeScript Handbook — Utility Types",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      },
      {
        "title": "MDN — Map (insertion-order iteration)",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
      },
      {
        "title": "TypeScript Deep Dive — Branded Types",
        "url": "https://basarat.gitbook.io/typescript/main-1/nominaltyping"
      }
    ]
  },
  {
    "date": "2026-02-19",
    "name": "Single-Pass Log Aggregator with Discriminated Unions",
    "difficulty": "Medium",
    "description": "You're building an observability dashboard for a microservices platform. Raw log entries stream in as heterogeneous records — each with a distinct `level` that determines what extra fields are present. You must aggregate them in a single pass into a strongly-typed summary report, with no data loss and no unsafe casting.",
    "snippet": "export interface ErrorLog {\n  level: \"error\";\n  message: string;\n  code: number;\n  timestamp: number;\n}\n\nexport interface HttpLog {\n  level: \"http\";\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  path: string;\n  statusCode: number;\n  responseMs: number;\n  timestamp: number;\n}\n\n// TODO: define LogEntry, LogLevel, LogSummary, then implement:\nexport function aggregateLogs(entries: LogEntry[]): LogSummary {\n  throw new Error(\"Not implemented\");\n}",
    "goals": [
      "Define the LogEntry discriminated union and derive LogLevel from it using an indexed access type — no manual string union allowed.",
      "Design the LogSummary type with a Record<LogLevel, number> count map, a typed ErrorLog array, a Set for warning services, and numeric aggregation fields.",
      "Implement aggregateLogs in a single pass using type narrowing (if/switch on entry.level) to safely access level-specific fields without any type assertions.",
      "Handle the empty-array edge cases correctly: avgResponseMs → 0, firstTimestamp → Infinity, lastTimestamp → -Infinity."
    ],
    "hints": [
      "LogLevel can be derived in one line with an indexed access type on LogEntry — look at how TypeScript lets you index a union with a key name.",
      "A single reduce whose accumulator carries all seven fields at once satisfies the single-pass requirement; initialise countByLevel with all five levels set to 0 so the Record type is always fully populated.",
      "A switch (entry.level) with exhaustive cases is the cleanest narrowing strategy here — TypeScript will fully narrow each branch so you never need `as` or `as unknown`."
    ],
    "docs": [
      {
        "title": "Discriminated Unions — TypeScript Handbook",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"
      },
      {
        "title": "Indexed Access Types — TypeScript Handbook",
        "url": "https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html"
      },
      {
        "title": "Record<Keys, Type> Utility Type",
        "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type"
      },
      {
        "title": "Narrowing — TypeScript Handbook",
        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html"
      }
    ]
  }
]
