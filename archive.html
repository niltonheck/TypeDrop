<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TypeDrop — Challenge Archive</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/fontsource/fonts/0x-proto@latest/latin-400-normal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/fontsource/fonts/0x-proto@latest/latin-700-normal.css">
  <link rel="icon" href="misc/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <main>
    <header>
      <h1><a href="index.html" style="color: inherit; text-decoration: none;">TypeDrop</a></h1>
      <p class="tagline">Challenge Archive</p>
    </header>

    <section class="challenge-card">
      <table class="archive-table">
        <thead>
          <tr>
            <th>Date</th>
            <th>Difficulty</th>
            <th>Challenge</th>
            <th>Description</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
        <tr>
          <td>2026-03-01</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Typed Distributed Cache with TTL &amp; Eviction Policies</td>
          <td>You're building the caching layer for a high-throughput microservice platform. Each cache namespace has its own value shape, TTL strategy, and eviction policy — and the orchestrator must coordinate reads, writes, and invalidations across multiple namespaces with full compile-time safety on every key-value pair.</td>
          <td><a href="archive/2026-03-01/typed-distributed-cache-with-ttl-and-eviction-policies.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-28</td>
          <td><span class="badge medium">Medium</span></td>
          <td>Typed Event Aggregator with Windowed Rollups</td>
          <td>You're building the analytics backbone of a real-time dashboard for a SaaS platform. Raw telemetry events (page views, clicks, errors, purchases) stream in continuously, and the dashboard needs per-event-type rollups aggregated over fixed time windows — all with zero `any` and full type safety on every event shape and its aggregated form.</td>
          <td><a href="archive/2026-02-28/typed-event-aggregator-with-windowed-rollups.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-27</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Typed Paginated API Client with Retry &amp; Concurrency</td>
          <td>You're building a typed data-ingestion pipeline for an analytics platform. Remote REST endpoints return paginated results, requests can fail transiently, and multiple endpoints must be fetched in parallel — but with a concurrency cap to avoid hammering the servers.</td>
          <td><a href="archive/2026-02-27/typed-paginated-api-client-with-retry-and-concurrency.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-26</td>
          <td><span class="badge easy">Easy</span></td>
          <td>Typed Product Inventory Aggregator</td>
          <td>You're building a back-office tool for an e-commerce warehouse. Raw inventory records arrive as unknown JSON, and you must safely validate them, group them by category, and compute per-category summaries — the challenge is keeping every step fully typed without reaching for `any`.</td>
          <td><a href="archive/2026-02-26/typed-product-inventory-aggregator.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-25</td>
          <td><span class="badge medium">Medium</span></td>
          <td>Typed Middleware Pipeline Builder</td>
          <td>You're building the request-handling core of an internal HTTP gateway. Middleware functions transform a typed context object one step at a time — the challenge is composing them into a pipeline where each middleware's output type flows into the next middleware's input type, all enforced at compile time.</td>
          <td><a href="archive/2026-02-25/typed-middleware-pipeline-builder.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-24</td>
          <td><span class="badge easy">Easy</span></td>
          <td>Typed Contact Book Lookup</td>
          <td>You're building a small contact book utility for an internal HR tool. Given a list of contacts with varying optional fields, you must build a strongly-typed lookup index and implement search/filter helpers — the challenge is in the types, not the logic.</td>
          <td><a href="archive/2026-02-24/typed-contact-book-lookup.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-23</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Typed Reactive State Machine</td>
          <td>You're building the core of a checkout flow for an e-commerce platform. The checkout process moves through well-defined states (idle → validating → payment → confirmed / failed), and every transition must be explicitly allowed, carry typed payloads, and notify strongly-typed subscribers — all enforced at compile time.</td>
          <td><a href="archive/2026-02-23/typed-reactive-state-machine.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-22</td>
          <td><span class="badge easy">Easy</span></td>
          <td>Typed Event Log Parser</td>
          <td>You're building a monitoring dashboard for a cloud platform. Raw event logs arrive as untyped JSON blobs — your job is to safely parse them into a discriminated union of strongly-typed events, then aggregate counts and extract the latest timestamp per event kind.</td>
          <td><a href="archive/2026-02-22/typed-event-log-parser.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-21</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Paginated API Client with Typed Result Accumulation</td>
          <td>You're building a typed API client for an analytics platform that exposes cursor-based paginated endpoints. The client must traverse all pages concurrently (up to a configurable limit), accumulate results into a strongly-typed aggregate, and surface per-page errors without aborting the entire fetch — all without a single `any` or type assertion.</td>
          <td><a href="archive/2026-02-21/paginated-api-client-with-typed-result-accumulation.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-20</td>
          <td><span class="badge easy">Easy</span></td>
          <td>Typed Inventory Aggregator</td>
          <td>You're building a dashboard for a small e-commerce warehouse. Given a flat list of product entries (each with a category, SKU, price, and stock count), aggregate them into a per-category summary — the hardest part is getting the TypeScript types exactly right.</td>
          <td><a href="archive/2026-02-20/typed-inventory-aggregator.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-19</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Typed Middleware Pipeline with Retry &amp; Cancellation</td>
          <td>You're building an internal HTTP gateway layer that processes outgoing requests through a chain of typed middleware (auth injection, logging, rate-limit headers). Each middleware can transform the request context, short-circuit with a typed error, and the pipeline runner supports per-request cancellation and automatic retry with exponential back-off.</td>
          <td><a href="archive/2026-02-19/typed-middleware-pipeline-with-retry-and-cancellation.html">See</a></td>
        </tr>
        </tbody>
      </table>
    </section>

    <footer>
      <p><a href="index.html">&larr; Back to today's challenge</a></p>
    </footer>
  </main>
</body>
</html>