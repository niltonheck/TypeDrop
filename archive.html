<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TypeDrop — Challenge Archive</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/fontsource/fonts/0x-proto@latest/latin-400-normal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/fontsource/fonts/0x-proto@latest/latin-700-normal.css">
  <link rel="icon" href="misc/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <main>
    <header>
      <h1><a href="index.html" style="color: inherit; text-decoration: none;">TypeDrop</a></h1>
      <p class="tagline">Challenge Archive</p>
    </header>

    <section class="challenge-card">
      <table class="archive-table">
        <thead>
          <tr>
            <th>Date</th>
            <th>Difficulty</th>
            <th>Challenge</th>
            <th>Description</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
        <tr>
          <td>2026-02-22</td>
          <td><span class="badge easy">Easy</span></td>
          <td>Typed Event Log Parser</td>
          <td>You're building a monitoring dashboard for a cloud platform. Raw event logs arrive as untyped JSON blobs — your job is to safely parse them into a discriminated union of strongly-typed events, then aggregate counts and extract the latest timestamp per event kind.</td>
          <td><a href="archive/2026-02-22/typed-event-log-parser.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-21</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Paginated API Client with Typed Result Accumulation</td>
          <td>You're building a typed API client for an analytics platform that exposes cursor-based paginated endpoints. The client must traverse all pages concurrently (up to a configurable limit), accumulate results into a strongly-typed aggregate, and surface per-page errors without aborting the entire fetch — all without a single `any` or type assertion.</td>
          <td><a href="archive/2026-02-21/paginated-api-client-with-typed-result-accumulation.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-20</td>
          <td><span class="badge easy">Easy</span></td>
          <td>Typed Inventory Aggregator</td>
          <td>You're building a dashboard for a small e-commerce warehouse. Given a flat list of product entries (each with a category, SKU, price, and stock count), aggregate them into a per-category summary — the hardest part is getting the TypeScript types exactly right.</td>
          <td><a href="archive/2026-02-20/typed-inventory-aggregator.html">See</a></td>
        </tr>
        <tr>
          <td>2026-02-19</td>
          <td><span class="badge hard">Hard</span></td>
          <td>Typed Middleware Pipeline with Retry &amp; Cancellation</td>
          <td>You're building an internal HTTP gateway layer that processes outgoing requests through a chain of typed middleware (auth injection, logging, rate-limit headers). Each middleware can transform the request context, short-circuit with a typed error, and the pipeline runner supports per-request cancellation and automatic retry with exponential back-off.</td>
          <td><a href="archive/2026-02-19/typed-middleware-pipeline-with-retry-and-cancellation.html">See</a></td>
        </tr>
        </tbody>
      </table>
    </section>

    <footer>
      <p><a href="index.html">&larr; Back to today's challenge</a></p>
    </footer>
  </main>
</body>
</html>